import java.text.NumberFormat
import com.kageiit.jacobo.JacoboTask

plugins {
    id "com.vanniktech.android.junit.jacoco"
    id "com.kageiit.jacobo"
}

junitJacoco {
    ignoreProjects = ['app'] // Create extension to configure which subprojects to ignore
    excludes = [
            '**/R.class',
            '**/R2.class', // ButterKnife Gradle Plugin.
            '**/R$*.class',
            '**/R2$*.class', // ButterKnife Gradle Plugin.
            '**/*$$*',
            '**/*$ViewInjector*.*', // Older ButterKnife Versions.
            '**/*$ViewBinder*.*', // Older ButterKnife Versions.
            '**/*_ViewBinding*.*', // Newer ButterKnife Versions.
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*$Lambda$*.*', // Jacoco can not handle several "$" in class name.
            '**/*Dagger*.*', // Dagger auto-generated code.
            '**/*MembersInjector*.*', // Dagger auto-generated code.
            '**/*_Provide*Factory*.*', // Dagger auto-generated code.
            '**/*_Factory*.*', // Dagger auto-generated code.
            '**/*$JsonObjectMapper.*', // LoganSquare auto-generated code.
            '**/*$inlined$*.*', // Kotlin specific, Jacoco can not handle several "$" in class name.
            '**/*$Icepick.*', // Icepick auto-generated code.
            '**/*$StateSaver.*', // android-state auto-generated code.
            '**/*AutoValue_*.*', // AutoValue auto-generated code.
            // Custom Added
            '**/*$Creator*', // Parcelize generated classes
            '**/databinding/*' // Data Binding
    ]
    includeInstrumentationCoverageInMergedReport = true // type boolean
    tasks.withType(Test) {
        jacoco.includeNoLocationClasses = true
        jacoco.excludes = ['jdk.internal.*' ]
    }
}

// Calculates Total Coverage
afterEvaluate {
    def overallCoverageReport = tasks.create("overallCoverageReport") {
        // Prints Coverage to be picked up by CI
        doLast {
            new File(buildDir, "reports/jacoco/index.html").readLines().each {
                def matcher = it =~ /(\d{1,3}(,\d{3})*) of (\d{1,3}(,\d{3})*)/
                if (matcher.count > 0) {
                    def format = NumberFormat.getInstance(Locale.US)
                    def missedInstructions = format.parse(matcher[0][1])
                    def totalInstructions = format.parse(matcher[0][3])
                    def coveragePercentage = (100.0 - 100.0*(missedInstructions/totalInstructions)).round(4)
                    println("Total Coverage = ${coveragePercentage}%")
                }
            }
        }
    }
    def reportMergedTask = tasks.findByName("mergeJacocoReports")
    reportMergedTask.finalizedBy("jacocoTestReportMerged")
    overallCoverageReport.dependsOn reportMergedTask
    subprojects { subproject ->
        if (junitJacoco.ignoreProjects.contains(subproject.name)) {
            return
        }
        def jacocoReport = "${subproject.name}:jacocoTestReportDebug"
        reportMergedTask.dependsOn jacocoReport
        reportMergedTask.mustRunAfter jacocoReport
    }
}

subprojects { subproject ->
    if (junitJacoco.ignoreProjects.contains(subproject.name)) {
        return
    }
    apply plugin: 'com.form.diff-coverage'

    /**
     * HACK Alert:
     * We need to config diffCoverageReport in `afterEvaluate` and use a shell task because
     * Jacoco Plugin uses `afterEvaluate` and we need access to `jacocoTestReportDebug` task when configuring `diffCoverageReport`
     * More info on this approach here: https://github.com/vanniktech/gradle-android-junit-jacoco-plugin/issues/171
     */
    afterEvaluate {
        // See https://github.com/vanniktech/gradle-android-junit-jacoco-plugin/issues/193#issuecomment-839662047
        tasks.withType(Test) {
            jacoco.excludes += ['jdk.internal.*']
        }
        def jacocoDiffCoverageTask = tasks.create("jacocoDiffCoverage") {
            dependsOn "jacocoTestReportDebug"

            doLast {
                def jacocoTestReport =
                        tasks.findByName("jacocoTestReportDebug") as org.gradle.testing.jacoco.tasks.JacocoReport
                if (!jacocoTestReport) {
                    println("Unable to find jacocoReport for subproject=$subproject")
                    return
                }

                def targetBranch = project.getProperties().get("targetBranch") ?: "development"
                def diffFile = new File(buildDir, "diff.patch")
                exec {
                    // Create the diff using `...` which matches what a merge request does
                    commandLine "bash", "-c", "git diff ${targetBranch}..."
                    standardOutput new FileOutputStream(diffFile)
                }
                diffCoverageReport {

                    diffSource.file = diffFile

                    jacocoExecFiles = files(jacocoTestReport.executionData)
                    classesDirs = files(jacocoTestReport.classDirectories)
                    srcDirs = files(jacocoTestReport.sourceDirectories)

                    reports {
                        html = true
                        xml = true
                    }
                }
                diffCoverage.executeAction()
            }
        }
        def coberturaTask = tasks.create("jacoboInternal", JacoboTask, {
            def jacocoReport = file("${project.buildDir}/reports/jacoco/diffCoverage/report.xml")
            onlyIf {
                return jacocoReport.exists()
            }
            it.jacocoReport = jacocoReport
            it.coberturaReport = file("${project.buildDir}/reports/cobertura/cobertura.xml")
            it.srcDirs = android.sourceSets.main.java.srcDirs
        })
        jacocoDiffCoverageTask.finalizedBy(coberturaTask)
    }
}




import java.text.NumberFormat

plugins {
    id "com.vanniktech.android.junit.jacoco"
    id "com.kageiit.jacobo"
}

import com.kageiit.jacobo.JacoboTask

junitJacoco {
    ignoreProjects = ['app', 'auth-sdk'] // Create extension to configure which subprojects to ignore
    excludes = [
            '**/R.class',
            '**/R2.class', // ButterKnife Gradle Plugin.
            '**/R$*.class',
            '**/R2$*.class', // ButterKnife Gradle Plugin.
            '**/*$$*',
            '**/*$ViewInjector*.*', // Older ButterKnife Versions.
            '**/*$ViewBinder*.*', // Older ButterKnife Versions.
            '**/*_ViewBinding*.*', // Newer ButterKnife Versions.
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*$Lambda$*.*', // Jacoco can not handle several "$" in class name.
            '**/*Dagger*.*', // Dagger auto-generated code.
            '**/*MembersInjector*.*', // Dagger auto-generated code.
            '**/*_Provide*Factory*.*', // Dagger auto-generated code.
            '**/*_Factory*.*', // Dagger auto-generated code.
            '**/*$JsonObjectMapper.*', // LoganSquare auto-generated code.
            '**/*$inlined$*.*', // Kotlin specific, Jacoco can not handle several "$" in class name.
            '**/*$Icepick.*', // Icepick auto-generated code.
            '**/*$StateSaver.*', // android-state auto-generated code.
            '**/*AutoValue_*.*', // AutoValue auto-generated code.
            // Custom Added
            '**/*$Creator*', // Parcelize generated classes
            '**/databinding/*' // Data Binding
    ]
    includeInstrumentationCoverageInMergedReport = true // type boolean
    tasks.withType(Test) {
        jacoco.includeNoLocationClasses = true
        jacoco.excludes = ['jdk.internal.*' ]
    }
}

// Calculates Total Coverage
afterEvaluate {
    def overallCoverageReport = tasks.create("overallCoverageReport") {
        // Prints Coverage to be picked up by CI
        doLast {
            new File(buildDir, "reports/jacoco/index.html").readLines().each {
                def matcher = it =~ /(\d{1,3}(,\d{3})*) of (\d{1,3}(,\d{3})*)/
                if (matcher.count > 0) {
                    def format = NumberFormat.getInstance(Locale.US)
                    def missedInstructions = format.parse(matcher[0][1])
                    def totalInstructions = format.parse(matcher[0][3])
                    def coveragePercentage = (100.0 - 100.0*(missedInstructions/totalInstructions)).round(4)
                    println("Total Coverage = ${coveragePercentage}%")
                }
            }
        }
    }
    def reportMergedTask = tasks.findByName("mergeJacocoReports")
    reportMergedTask.finalizedBy("jacocoTestReportMerged")
    overallCoverageReport.dependsOn reportMergedTask
    subprojects { subproject ->
        if (junitJacoco.ignoreProjects.contains(subproject.name)) {
            return
        }
        def jacocoReport = "${subproject.name}:jacocoTestReportDebug"
        reportMergedTask.dependsOn jacocoReport
        reportMergedTask.mustRunAfter jacocoReport
    }

    // Create Cobertura Report for Gitlab
    def coberturaTask = tasks.create("overallCobertura", JacoboTask, {
        def jacocoReport = file("${project.buildDir}/reports/jacoco/jacoco.xml")
        onlyIf {
            return jacocoReport.exists()
        }
        it.jacocoReport = jacocoReport
        it.coberturaReport = file("${project.buildDir}/reports/cobertura/cobertura.xml")
        def overallJacocoTask = tasks.findByName("jacocoTestReportMerged")
        it.srcDirs = overallJacocoTask.sourceDirectories
    })
    overallCoverageReport.finalizedBy(coberturaTask)
}
